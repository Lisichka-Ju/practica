# Конспект лекции 4: Архитектура Web

## Внутреннее устройство браузера
- Браузер сначала загружает основную структуру HTML, затем отправляет дополнительные GET-запросы для получения ресурсов (картинки, файлы, скрипты, таблицы стилей и так далее).
- Поэтому по мере загрузки страницы браузер и сервер продолжают обмениваться между собой информацией.
- Как только рендеринг завершен — пользователю отобразится полностью загруженная страница сайта.

## Критические этапы рендеринга
Критические этапы рендеринга (Critical Rendering Path) - это
последовательность шагов, которые выполняет браузер, когда
преобразуется HTML, CSS и JavaScript в пиксели, которые вы видите на
экране
1. Загрузка HTML
2. Построение DOM (Document Object Model)
3. Построение CSSOM (CSS Object Model)
4. Формирование Render Tree (комбинация DOM и CSSOM)
5. Компоновка (layout) - определение положения и размеров элементов
6. Отрисовка (paint) - отображение пикселей на экране

## DOM (Document Object Model) и CSSOM (CSS Object Model)
- DOM представляет содержимое страницы в виде иерархического дерева узлов.
- CSSOM содержит все стили страницы. Браузер блокирует рендеринг до полной загрузки CSS.

## Дерево рендера (Render Tree)
Дерево рендера охватывает сразу и содержимое страницы, и стили: это место, где DOM и CSSOM деревья комбинируются в одно дерево. 

## Компоновка (layout)
В тот момент, когда дерево рендера (render tree) построено, становится возможным этап компоновки (layout).
Layout — это рекурсивный процесс определения положения и размеров элементов из Render Tree.
Он начинается от корневого Render Object, которым является, и проходит рекурсивно вниз по части или всей иерархии дерева высчитывая геометрические размеры дочерних render object'ов.
Корневой элемент имеет позицию (0,0) и его размеры равны размерам видимой части окна.
К концу процесса layout каждый render object имеет свое положение и размеры.

## Отрисовка (paint)
Последний этап в нашем списке - отрисовка (paint) пикселей на экране
Когда дерево рендера (render tree) создано, компоновка (layout) произошла,
пиксели могут быть отрисованы.
При первичной загрузке документа (onload) весь экран будет отрисован.
После этого будут перерисовываться только необходимые к обновлению
части экрана.

## Ограничения JS в браузере
● Нельзя взаимодействовать с файловой системой
● Нет доступа к сетевым функциям, кроме того, что предоставляет сам
браузер
● Нет возможности организовывать многопоточные вычисления. Есть
воркеры, но они имеют определенные ограничения
● Нельзя создавать новые процессы / запускать программы (открытие
новых вкладок не считается)

## NPM и управление зависимостями
- Node.js позволяет выполнять JavaScript вне браузера.
- NPM (Node Package Manager) - инструмент для управления пакетами:
  - CLI для установки и публикации пакетов
  - Онлайн-репозиторий пакетов
- Способы подключения библиотек:
  - Через CDN (Content Delivery Network)
  - Через NPM (установка зависимостей локально)

## Архитектурные принципы
Если некоторое решение размазано ровным слоем по всему приложению, то стоимость его изменения будет огромной, а значит это решение является архитектурным

## Методологии и принципы
- **DRY** (Don't Repeat Yourself) - избегание дублирования кода
- **KISS** (Keep It Simple Stupid) - простота решений
- **SOLID** - пять принципов ООП

## Декомпозиция (функциональная)
Во главе функциональной декомпозиции лежит паттерн Модуль
Модуль — это Функция + Данные, необходимые для её выполнения
● Инкапсуляция данных
● Явное управление зависимостями (создание чёткой структуры
подключаемых модулей)
● Уход от засорения глобального контекста

## Проектирование системы
● Какую функцию выполняет каждый модуль?
● Насколько модули легко тестировать?
● Возможно ли использовать модули самостоятельно
или в другом окружении?
● Как сильно изменения в одном модуле отразятся на
остальных?

## Критерии хорошего дизайна системы
● Эффективность системы
● Гибкость и расширяемость системы
● Масштабируемость процесса разработки
● Тестируемость и сопровождаемость
● Возможность повторного использования

## Декомпозиция (компоненты)
Компонентный подход - разделение кода приложения на независимые, слабосвязанные и переиспользуемые компоненты

## Фильтрация и группировка
● У нас есть список билетов, но мы хотим их использовать по разному
● Показать самые дешевые, самые быстрые, другие пользовательские фильтры
● Сгруппировать по странам, по пересадкам, по дням
● Сортировка, дополнительные представления (графики, гистограммы)
● Выход: отделить данные и их представление

## Шаблоны MVC
Шаблон MVC (Модель-Вид-Контроллер или Модель-Состояние-Поведение) 
описывает простой способ построения структуры приложения, целью которого является отделение бизнес-логики от  пользовательского интерфейса.
В результате, приложение легче масштабируется, тестируется, сопровождается и, конечно же, реализуется

## Модели MVC
● Cодержит бизнес-логику приложения: методы для получения и обработки
данных
● Не взаимодействуют с напрямую пользователем
● Не генерируют никакого HTML (не управляют отображением данных)
● Модели могут хранить в себе данные и они могут взаимодействовать с другими
моделями

## Представления MVC
● Отвечают за отображение данных, содержат в себе вызовы
шаблонизаторов, создание блоков и компонентов и всего такого
● Получают данные от напрямую от моделей или от контроллеров
● Взаимодействуют с моделями посредством контроллеров
● Являются посредниками между пользователем и контроллером

## Контроллеры MVC
● Являются связующим звеном приложения
● Реализуют взаимодействие между вьюхами и моделями и взаимодействие вьюх друг с другом
● Должны содержать минимум бизнес-логики и быть максимально простыми в конфигурации (для возможности удобного изменения и расширения приложения)
● Логика контроллера довольно типична и большая ее часть выносится в базовые классы, в отличие от моделей, логика которых, как правило, довольно специфична для конкретного приложения

## Собираем MVC
● Создаём базовый класс View
● Наследуем от него MenuView, SignView, ScoreboardView...
● Во вьюхах описываем описываем отображение определённой части приложения
● Содержимое View генерируется с помощью шаблонизатора
● Далее на основе уже имеющейся разметки создаются блоки и компоненты, либо они генерируются динамически на каком-то этапе жизненного цикла приложения
● Каждый момент времени активна только одна View

## Роутинг и History API
- Роутер определяет, какое представление отображать в зависимости от URL  
- History API позволяет управлять историей браузера в SPA (Single Page Applications)
---
# Архитектура CSS
---
## Архитектура CSS
Как стили попадают на страницу
● Браузерные стили
● link rel=”stylesheet”
● тег style
● атрибут style
Проблемы традиционных подходов:
  - Сильная связанность со структурой документа  
  - пересечение имён с внешними библиотеками или даже внутри собственного проекта
   
## Признаки хорошей архитектуры
● Предсказуемость — изменение текущих стилей не ломает проект
● Масштабируемость — добавление новых стилей не ломает проект
● Поддержка — все в команде понимают, как писать стили
● Повторное использование — DRY

# Объектно-ориентированный CSS
Разделение контейнера и содержимого
Принцип: внешний вид элемента не зависит от того, где он расположен.
Вместо .my-element button создаем отдельный стиль .control для конкретного случая Зачем?
● Все button будут выглядеть одинаково
● К любому элементу можно добавить класс .control. Работает как mixin .my-element button не нужно переопределять, если передумали

## Выводы
● Избавляемся от каскадирования!
● Придумываем слои: компонент -> приложение -> глобальные стили
● Держим стили внутри своего слоя: button.html + button.css + button.js
● Расширяем компоненты через глобальные mixin-классы: .animated,
.themed, .hidden, .row
Проблемы:
● Коллизия стилей

## CSS через JS
Идея: представить стили через объект, записывать их в тег style, когда
посчитаем нужным
