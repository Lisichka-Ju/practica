# Лекция 3: Углубленный JavaScript
---
# Продвинутая работа с функциями
---
## Rest-оператор
Используется для сбора всех оставшихся аргументов функции в массив.
**Пример:**
```javascript
function sumAll(...args) {
    let sum = 0;
    for (let arg of args) sum += arg;
    return sum;
}
```

### Spread-оператор
Позволяет разложить элементы массива в отдельные аргументы.
**Пример:**
```javascript
const arr1 = [0, -2, 1, 5];
const arr2 = [100, 200, 300, -322];
console.log(Math.max(...arr1, ...arr2));
```

### Замыкание
Функция запоминает своё лексическое окружение даже после завершения выполнения.
**Пример:**
```javascript
function makeWorker() {
    let name = "Pete";
    return function() {
        alert(name);
    };
}
let name = "John";
let work = makeWorker();
work(); // "Pete"
```

## Лексическое окружение
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть
связанный с ними внутренний (скрытый) объект, называемый лексическим
окружением LexicalEnvironment.
Объект лексического окружения состоит из двух частей:
● Environment Record – объект, в котором как свойства хранятся все
локальные переменные (а также некоторая другая информация, такая
как значение this).
● Ссылка на внешнее лексическое окружение – то есть то, которое
соответствует коду снаружи (снаружи от текущих фигурных скобок)
"Переменная" – это просто свойство специального внутреннего
объекта: Environment Record. «Получить или изменить переменную»,
означает, «получить или изменить свойство этого объекта».
- Переменная – это свойство специального внутреннего объекта, связанного с
текущим выполняющимся блоком/функцией/скриптом.
- Работа с переменными – это на самом деле работа со свойствами этого
объекта.
В отличие от переменных, объявленных с помощью let, Function Declaration
полностью инициализируются не тогда, когда выполнение доходит до них, а раньше,
когда создаётся лексическое окружение.
Все функции «при рождении» получают скрытое свойство [[Environment]], которое
ссылается на лексическое окружение места, где они были созданы.
Immediately-Invoked Function Expressions - функция, которая вызывается
сразу после ее объявления.

## Устаревшее объявление переменных
Существует 2 основных отличия var от let/const:
● Переменные var не имеют блочной области видимости, они ограничены,
как минимум, телом функции.
● Объявления (инициализация) переменных var производится в начале
исполнения функции (или скрипта для глобальных переменных).

## Функции-обёртки (декораторы)
Позволяют добавлять дополнительное поведение к функциям.

**Пример:**
```javascript
function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) return cache.get(x);
        let result = func.call(this, x);
        cache.set(x, result);
        return result;
    };
}
```

## Привязывание контекста
Методы `call`, `apply` и `bind` позволяют явно указать контекст вызова функции.

**Пример:**
```javascript
function say(phrase) {
    alert(this.name + ': ' + phrase);
}
let user = { name: "John" };
say.call(user, "Hello"); // "John: Hello"
```
---
# Прототипы и наследование
---
[[Prototype]]
В JavaScript объекты имеют специальное скрытое
свойство [[Prototype]] (так оно названо в
спецификации), которое либо равно null, либо
ссылается на другой объект. Этот объект называется
«прототип»


## Прототипное наследование
- Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. Можно задать через __proto__.
- Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. Можно задать через __proto__. Обход прототипов происходит от самого дочернего, вниз к родительским.

**Пример:**
```javascript
let animal = { eats: true };
let rabbit = { jumps: true };
rabbit.__proto__ = animal;
alert(rabbit.eats); // true
```
---
# Продвинутые классы
---
**Пример:**
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    run(speed) {
        alert(`${this.name} бежит со скоростью ${speed}.`);
    }
}

class Rabbit extends Animal {
    hide() {
        alert(`${this.name} прячется!`);
    }
}
let rabbit = new Rabbit("Белый кролик");
rabbit.run(5); // "Белый кролик бежит со скоростью 5."
```
---
# Модули
---
## Модули
● AMD - одна из самых старых модульных систем, изначально
реализована библиотекой require.js.
● CommonJS – модульная система, созданная для сервера Node.js.
● UMD - ещё одна модульная система, предлагается как универсальная,
совместима с AMD и CommonJS.

## Модули (ESM)
Модуль – это просто файл. Один скрипт – это один модуль.
Модули могут загружать друг друга и использовать директивы export и
import, чтобы обмениваться функциональностью, вызывать функции одного
модуля из другого:
● export отмечает переменные и функции, которые должны быть
доступны вне текущего модуля
● import позволяет импортировать функциональность других модулей

## Экспорт и импорт
Позволяют разделять код на отдельные файлы и использовать их функциональность.

**Пример:**
```javascript
// sayHi.js
export function sayHi(user) {
    alert(`Hello, ${user}!`);
}
---
// main.js
import { sayHi } from './say.js';
sayHi('John'); // "Hello, John!"
```
---
# Обработка ошибок
---
## Try...catch
Позволяет обрабатывать ошибки в коде.

## Ошибка (объект ошибки)
● name - имя ошибки.
● message – сообщение ошибки.
● stack - текущий стек вызова.

## Пользовательские ошибки
Можно создавать собственные классы ошибок.
---
# Регулярные выражения
---
## Создание и использование
Используются для поиска и замены текста.

**Пример:**
```javascript
let str = "Люблю JavaScript!";
let regexp = /любю/i;

alert(regexp.match(str)); 
```
---
# События
---
События мыши:
● click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами
оно происходит при касании).
● contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
● mouseover / mouseout – когда мышь наводится на / покидает элемент.
● mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
● mousemove – при движении мыши.
События на элементах управления:
● submit – пользователь отправил форму <form>.
● focus – пользователь фокусируется на элементе, например нажимает на <input>.
Клавиатурные события:
● keydown и keyup – когда пользователь нажимает / отпускает клавишу.

## Обработчики событий
Позволяют реагировать на действия пользователя.

## События (объект события)
● event.type - тип события.
● event.currentTarget – элемент, на котором сработал обработчик.
● event.clientX / event.clientY - координаты курсора.

### События (всплытие и погружение)
События сначала погружаются от корня к целевому элементу, а затем всплывают обратно.
Клик по внутреннему <p> вызовет обработчик onclick:
1. Сначала на самом <p>.
2. Потом на внешнем <div>.
3. Затем на внешнем <form>.
4. И так далее вверх по цепочке
до самого document.


