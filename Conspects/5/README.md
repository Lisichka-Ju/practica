# Лекция 5: Node.js

## Поиск сервера
Работу сайта обеспечивает сервер. У сервера есть адрес - IP-адрес.
Такая информация хранится в распределенной системе серверов — DNS (Domain Name System). Система работает как общая «контактная книга», хранящаяся на распределенных серверах и устройствах в интернете.


## TCP-соединение
Как только браузер узнал IPадрес нужного сервера, он пытается установить с ним соединение. В большинстве случаев для этого используется специальный протокол — TCP.
Для установления TCP соединения используется система трех рукопожатий.

## Тройное рукопожатие
● Устройство пользователя отправляет специальный запрос на установку соединения с сервером — называется SYN-пакет.
● Сервер в ответ отправляет запрос с подтверждением получения SYNпакета — называется SYN/ACKпакет.
● В конце устройство пользователя при получении SYN/ACK-пакета отправляет пакет с подтверждением — ACK-пакет. В этот момент соединение считается установленным.

## Клиент-серверная модель
Клиент – серверная модель — вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами

## Веб-страницы и серверный рендеринг
- **Статические страницы**: Отображаются браузером без изменений (HTML, CSS).
- **SSR (Server Side Rendering)**: Сервер генерирует динамические страницы, обрабатывает запросы и взаимодействует с базой данных.

## Веб-приложения и REST
- **Frontend**: Генерация интерфейса, взаимодействие с пользователем, запросы к API.
- **Backend**: Реализация API, работа с базой данных.
- **REST**: Каждый запрос содержит всю необходимую информацию для выполнения действия сервером.

## Node.js
Среда выполнения JavaScript на движке V8. Используется для:
- Веб-приложений (бэкенд).
- Десктопных приложений (Electron.js).
- Микроконтроллеров (Espurino).
- Консольных утилит.
- Машинного обучения (TensorFlow.js).

### Преимущества Node.js
-Node.js - это платформа для разработки очень быстрого сервера. По производительности спокойно может сравниться с Java, Kotlin и Golang.  
- При этом все вышеперечисленные языки имею вложенные механизмы параллелизма (корутины, потоки и тд), а Node.js однопоточный.  
- Движок V8 из коробки поддерживает исключительно асинхронное API, т.к. изначально был предназначен для работы в браузере на клиенте. Это значит, что ни одна из read/write операций не блокирует основной поток
исполнения (спасибо Event Loop).
- Поднять простой веб-сервер на Node.js - это 15 строк кода (с натяжкой).  
- При этом, т.к. мы пишем на javascript, мы можем использовать различные парадигмы для написания кода.

### Проблемы JavaScript
- Отсутствие строгой типизации.
- плохое ООП, несмотря на его наличие.
- Отсутствие многопоточности.
- Медленные вычисления.
- скудные коллекции (по сравнению с java, но великолепные по-сравнению с Go)
- RunTime-ошибки - код запустился, но упал во время исполнения. Такая возможность есть из-за того, что javascript интерпретируемый язык программирования.

## Использование Node.js
1. Создаем файл <название>.js
2. Пишем туда код на javascript
3. Запускаем командой node <название>.js
4. Обращаемся по HTTP

Пример сервера:
```javascript
const http = require("http");

const HOST = 'localhost';
const PORT = 8000;

const handler = (req, res) => {
    res.writeHead(200);
    res.end('JavaScript - классный язык программирования!');
};

const server = http.createServer(handler);
server.listen(PORT, HOST, () => {
    console.log(`Сервер запущен по адресу http://${HOST}:${PORT}`);
});
```

## Стандартная библиотека Node.js
● events - встроенный EventEmitter
● fs - работа с файловой системой
● os - работа с операционной системой
● http - основной модуль для создания http-серверов
● net - низкоуровневое сетевое соединение
● path - для работы с путями в директориях

## Как используют Node.js ?
Прежде всего для серверной разработки.
Например:
● SSR - серверный рендеринг для SPA
● BFF - бэкенд-прокси для агрегации данных
● Full-Backend API - полноценный бэкенд
● различные микросервисы со специфической логикой

## Nest.js
Nest.js - это фреймворк для создания эффективных, расширяемых серверных приложений. ОБЯЗАТЕЛЬНО на TypeScript
Преимущества:
● готовую архитектуру;
● готовые решения для middleware;
● удобные механизмы валидации;
● возможность grpc почти из коробки;
● dependency injection
● java-подобное приложение.

## TypeScript
TypeScript — язык программирования, представленный Microsoft в
2012 году. TypeScript является обратно совместимым с JavaScript и
компилируется в последний. TypeScript отличается от JavaScript
возможностью явного статического назначения типов, а также поддержкой
подключения модулей

## Преимущества TypeScript
● Аннотации типов и проверка их согласования на этапе компиляции
● Интерфейсы, кортежи, декораторы свойств и методов, расширенные
возможности ООП
● TypeScript — надмножество JavaScript, поэтому любой код на JavaScript
будет выполнен и в TypeScript
● Широкая поддержка IDE и адекватный автокомплит
● Поддержка ES6-модулей из коробки

## Postman
Инструмент для тестирования API. Пример использования:
- Отправка JSON для создания новой записи.
- Проверка ответов сервера.

## Модель и контроллер в NestJS
- **Модель**: Данные хранятся в массиве или файле. Логика работы с данными реализуется в сервисе.
- **Контроллер**: Обрабатывает HTTP-запросы и взаимодействует с сервисом.

Пример сервиса:
```typescript
@Injectable()
export class StocksService {
    constructor(private fileService: FileService<Stock[]>) {}

    create(createStockDto: CreateStockDto) {
        const stocks = this.fileService.read();
        const stock = { ...createStockDto, id: stocks.length + 1 };
        this.fileService.add(stock);
    }

    findAll(): Stock[] {
        const stocks = this.fileService.read();

        return stoks;
    }
}
```

Пример контроллера:
```typescript
@Controller('stocks')
export class StocksController {
    constructor(private readonly stocksService: StocksService) {}

    @Post()
    create(@Body() createStockDto: CreateStockDto) {
        return this.stocksService.create(createStockDto);
    }

    @Get()
    findAll() {
        return this.stocksService.findAll();
    }
}
```
